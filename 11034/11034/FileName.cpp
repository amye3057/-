#include <stdio.h>

int main() {
	int a, b, c;
	while (scanf("%d %d %d", &a, &b, &c) != EOF) {
		int ans;
		if (b - a > c - b)
			ans = b - a;
		else
			ans = c - b;
		ans--;
		printf("%d\n", ans);
	}
	return 0;
}


// 아래는.. 루프를 전부 돌려고 내가 짠 식인데..
// 처음에는 a b c가 있을 때, a나 c가 안쪽으로 움직일 때 반드시 중간에 있어야 한다고 생각했다. ex) 1 3 7 이동 시 1에 위치한 캥거루는 3과 7의 중간인 5로 이동 -> 3 5 7
// 근데 최대 이동을 구하라고 했다. 생각해보니 안쪽으로 계속 붙으면 된다. ex) 1 3 7 -> 3 4 7 -> 4 5 7 -> 5 6 7  또는 1 3 7 -> 3 6 7 -> 3 5 6 -> 3 4 5 이렇게..
// 그럼 맨 처음 이동 빼고는 계속 붙어서 이동하는 거니까..
// 일단 더 큰 쪽으로 이동해서 계속 이동하는 것이므로 더 넓은 크기의 값을 고른 뒤, 그 값에서 1만 빼주면 되는거였다..
// 허무하다..

/*#include <stdio.h>

int main() {
	int a,b,c;
	while (scanf_s("%d %d %d", &a, &b, &c) != EOF) {
		int t = 0;
		while (t!=10) { // 무한루프 일단 없앰
			if (b - a == 1 && c - b == 1) // 더 이상 이동이 불가능
				break;

			// 빈 공간이 더 넓은 쪽으로 이동할거임.
			if (b - a > c - b) { // 왼쪽~중간 공간이 더 넓을 경우
				int x = b;
				b = b - 1; // 중간 옆에 붙임
				c = x;
			}
			else { // 중간~오른쪽 공간이 더 넓거나, 같은 경우. (공간 크기가 같은 경우에는 어느쪽으로 가든 상관이 없으므로)
				int x = b;
				b = b + 1; // 중간 옆에 붙임
				a = x;
			}
			printf("a:%d, b:%d, c:%d\n", a, b, c);
			t++;
		}
		printf("%d", t);
	}

	return 0;
}*/